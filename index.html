<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Tech - Future Landing Page</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- 1. CORE STYLES --- */
        :root {
            --primary: #00f2ff;
            --secondary: #bd00ff;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #ffffff;
            --text-muted: #a0a0a0;
        }

        body {
            margin: 0;
            background-color: #020207;
            font-family: 'Roboto', sans-serif;
            color: var(--text-main);
            overflow-x: hidden; /* Chặn cuộn ngang */
        }

        /* --- 2. 3D BACKGROUND (QUAN TRỌNG) --- */
        canvas {
            display: block;
            position: fixed; /* Ghim chặt canvas vào màn hình */
            top: 0;
            left: 0;
            z-index: -1; /* Đẩy xuống dưới cùng */
        }

        /* --- 3. LAYOUT & TYPOGRAPHY --- */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        section {
            padding: 100px 0;
            min-height: 80vh; /* Mỗi section chiếm ít nhất 80% chiều cao màn hình */
            display: flex;
            align-items: center;
            position: relative;
        }

        h1, h2, h3 {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            margin: 0 0 20px 0;
        }

        h1 {
            font-size: 4rem;
            line-height: 1.1;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        h2 { font-size: 2.5rem; color: var(--primary); }
        p { font-size: 1.1rem; line-height: 1.6; color: var(--text-muted); margin-bottom: 30px; }

        /* --- 4. NAVIGATION --- */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            padding: 20px 0;
            z-index: 100;
            background: rgba(2, 2, 7, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--glass-border);
        }
        
        .nav-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo { font-family: 'Orbitron'; font-weight: bold; font-size: 1.5rem; color: #fff; }
        
        .nav-links a {
            color: #fff;
            text-decoration: none;
            margin-left: 30px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: 0.3s;
        }
        .nav-links a:hover { color: var(--primary); }

        /* --- 5. GLASS CARDS (Hiệu ứng kính) --- */
        .glass-card {
            background: var(--glass);
            backdrop-filter: blur(12px); /* Làm mờ hậu cảnh sau card */
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 40px;
            transition: transform 0.3s ease;
        }
        
        .glass-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary);
            box-shadow: 0 10px 30px rgba(0, 242, 255, 0.1);
        }

        /* --- 6. SECTIONS SPECIFIC --- */
        /* Hero Section */
        #hero { height: 100vh; }
        .hero-content { max-width: 800px; }
        
        .btn {
            display: inline-block;
            padding: 15px 40px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: #fff;
            text-decoration: none;
            font-weight: bold;
            border-radius: 50px;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.4);
            transition: 0.3s;
        }
        .btn:hover { box-shadow: 0 0 40px rgba(0, 242, 255, 0.8); transform: scale(1.05); }

        /* Features Section (Grid) */
        .grid-3 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            width: 100%;
        }
        
        /* Footer */
        footer {
            text-align: center;
            padding: 50px 0;
            background: rgba(0,0,0,0.8);
            color: var(--text-muted);
            font-size: 0.9rem;
        }

    </style>
</head>
<body>

    <nav>
        <div class="container nav-content">
            <div class="logo">QUANTUM.IO</div>
            <div class="nav-links">
                <a href="#hero">Home</a>
                <a href="#about">About</a>
                <a href="#features">Solutions</a>
                <a href="#contact">Contact</a>
            </div>
        </div>
    </nav>

    <section id="hero">
        <div class="container">
            <div class="hero-content">
                <h1>The Next Era of <br> Digital Experience</h1>
                <p>Khám phá công nghệ tương tác dòng chảy hạt (Particle Flow) trên nền tảng WebGL. Tối ưu hóa hiệu năng, trải nghiệm mượt mà trên mọi thiết bị.</p>
                <a href="#about" class="btn">Explore Now</a>
            </div>
        </div>
    </section>

    <section id="about">
        <div class="container">
            <div class="glass-card">
                <h2>Our Vision</h2>
                <p>Chúng tôi không chỉ viết mã, chúng tôi tạo ra nghệ thuật số. Sử dụng sức mạnh của GPU để xử lý hàng ngàn tác vụ song song, mang lại trải nghiệm thị giác chưa từng có trên trình duyệt web.</p>
                <p>Công nghệ Shader (GLSL) cho phép kiểm soát từng điểm ảnh, từng chuyển động nhỏ nhất, tạo ra sự sống động mà các thư viện UI truyền thống không thể làm được.</p>
            </div>
        </div>
    </section>

    <section id="features">
        <div class="container">
            <h2 style="text-align: center; margin-bottom: 50px;">Core Features</h2>
            <div class="grid-3">
                <div class="glass-card">
                    <h3>High Performance</h3>
                    <p>Sử dụng Three.js BufferGeometry và WebGL Renderer giúp đạt 60 FPS ngay cả trên thiết bị cấu hình thấp.</p>
                </div>
                <div class="glass-card">
                    <h3>Interactive</h3>
                    <p>Hệ thống phản hồi theo thời gian thực với vị trí chuột của người dùng, tạo cảm giác kết nối sâu sắc.</p>
                </div>
                <div class="glass-card">
                    <h3>Creative Design</h3>
                    <p>Phong cách thiết kế Cyberpunk kết hợp Glassmorphism tạo nên vẻ đẹp hiện đại và tương lai.</p>
                </div>
            </div>
        </div>
    </section>

    <footer>
        <p>© 2025 Quantum Creative. Built with Three.js & GLSL.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="x-shader/x-vertex" id="vertexShader">
        uniform float uTime;
        uniform vec2 uMouse;
        attribute float aRandom;
        varying vec3 vColor;

        // Simplex Noise Function
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
            vec3 pos = position;
            float time = uTime * 0.15;
            float noiseX = snoise(vec3(pos.x * 0.02, pos.y * 0.02, time + aRandom));
            float noiseY = snoise(vec3(pos.x * 0.02, pos.y * 0.02, time + aRandom + 10.0));
            pos.x += noiseX * 0.3;
            pos.y += noiseY * 0.3;
            float boundary = 40.0;
            pos.x = mod(pos.x + boundary, boundary * 2.0) - boundary;
            pos.y = mod(pos.y + boundary, boundary * 2.0) - boundary;
            
            // Mouse Interaction
            vec4 screenPos = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            vec2 ndcPos = screenPos.xy / screenPos.w;
            float dist = distance(ndcPos, uMouse);
            float mouseRadius = 0.3;
            if (dist < mouseRadius) {
                vec2 dir = normalize(ndcPos - uMouse);
                float force = (mouseRadius - dist) * 3.0;
                pos.x += dir.x * force * 2.0;
                pos.y += dir.y * force * 2.0;
                pos.z += force * 5.0; 
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            gl_PointSize = (8.0 * (1.0 + aRandom)) * (1.0 / -mvPosition.z);
            
            vec3 color1 = vec3(0.0, 0.8, 1.0); 
            vec3 color2 = vec3(0.6, 0.0, 1.0); 
            float mixFactor = smoothstep(-20.0, 20.0, pos.x) + noiseX * 0.2;
            vColor = mix(color1, color2, mixFactor);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        varying vec3 vColor;
        void main() {
            float dist = distance(gl_PointCoord, vec2(0.5));
            if (dist > 0.5) discard;
            float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
            gl_FragColor = vec4(vColor, alpha * 0.8);
        }
    </script>

    <script>
        const PARTICLE_COUNT = 15000;
        let renderer, scene, camera, particleSystem, uniforms;

        function init() {
            // Renderer (giữ cấu hình Safe Mode cho Ubuntu của bạn)
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                failIfMajorPerformanceCaveat: false 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0); // Quan trọng: Màu nền trong suốt để thấy body color
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const randoms = new Float32Array(PARTICLE_COUNT);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 80;
                positions[i3 + 1] = (Math.random() - 0.5) * 80;
                positions[i3 + 2] = (Math.random() - 0.5) * 50;
                randoms[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

            uniforms = {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector2(9999, 9999) },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            };

            const material = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                uniforms: uniforms,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
        }

        function onWindowResize() {
            camera.aspect
